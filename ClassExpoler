package testreflect;

import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.InputStream;
import java.lang.StringBuilder;
/**
 * 关于反射的一些定义：
 * 能够来分析目的类能力的程序,称为反射。 
 * ——参考来自Core Java Volume I——Fundamentals P197-P200
 * 先简单了解一下，反射的作用：分析类。需要java.lang.reflect的Constructor,Field,Method,以及java.lang.Class类
 */
public class ClassExpoler {

	/**
	 * 在命令行输出所有目的类声明的构造器（方法）
	 * 
	 * @param object
	 *            object the analysed Class
	 */
	public static void printAllDeclaredConstructors(Class object) {
		Constructor[] cons = object.getConstructors();
		// 所有的类都必须有构造方法。所以cons.length>=1
		System.out.println("Constructots:");
		for (Constructor c : cons) {
			System.out.println(c.toString());
		}
	}

	/**
	 * 在命令行输出所有目的类声明的方法
	 * 
	 * @param object
	 *            object the analysed Class
	 */
	public static void printAllDeclaredMethods(Class object) {
		Method[] methods = object.getDeclaredMethods();
		// 类中不一定声明了方法
		System.out.println("Methods:");
		for (int i = 0; i < methods.length; i++) {
			System.out.println(methods[i].toString());
		}
	}

	/**
	 * 在命令行输出所有目的类声明的成员属性（字段、域）
	 * 
	 * @param object
	 *            object the analysed Class
	 */
	public static void printAllDeclaredFileds(Class object) {
		Field[] fields = object.getDeclaredFields();
		// 类中不一定有成员属性
		System.out.println("Fileds:");
		for (int i = 0; i < fields.length; i++) {
			System.out.println(fields[i].toString());
		}
	}

	/**
	 * 读取Simple.cfg配置文件中的配置，利用反射机制来实现动态地加载所需类，让它自动地执行下面的操作.
	 * @param f the configfile
	 * @return detailCfg the messages that we get from configfile,such as Class,Method,Field
	 * @throws Exception 
	 */
	public static HashMap readCfg(File f) throws Exception{
		FileReader read = new FileReader(f);//windows默认本地是GBK，所以用GBK写配置文件。
		String encoding = read.getEncoding();
		HashMap<String, String> detailCfg = new HashMap<>(5);//返回一个HashMap.存储了配置信息。
		
		if(f.length()>Integer.MAX_VALUE)
			throw new Exception("文件过大");
		if(f.length()==0)
			throw new Exception("配置文件内容为空！");
		
		char[] cfg = new char[(int)f.length()];
		read.read(cfg);
		StringBuilder origCfg = new StringBuilder();
		origCfg.append(cfg);
		String secCfg = origCfg.toString();
		String[] details = secCfg.split("\n");
//一个自制的简单配置文件识别参数~
		String className = details[0].split(":")[1];//也可以用foreach循环来做，不过我这里只配置一个类所以就算了~对于配置多个类应该还要换一种存储结构。
		detailCfg.put("Class", className.trim());
		
		String temp = details[1].split(":")[1];
		String methodName = temp.split(" ")[0];
		String paramType = temp.split(" ")[1];
		detailCfg.put("Method", methodName.trim());
		detailCfg.put("ParamType", paramType.trim());
		
		temp = details[2].split(":")[1];
		String fieldName = temp.split(" ")[0];
		String fieldparam = temp.split(" ")[1];
		String value = temp.split(" ")[2];
		detailCfg.put("Field", fieldName.trim());
		detailCfg.put("FieldParam", fieldparam.trim());
		detailCfg.put("Value", value.trim());
		
		return detailCfg;
	}
	public static void main(String[] agrs) {
		try {
			/**4.10
			 * 1.通过已知类包的路径如java.lang.String，可以直接让JVM去加载这个类，并且获取这个类类型的引用交给aim（是类类型Class，不是实例对象instantance）
			 * 2.通过aim，可以获取到String的构造器，方法，字段等信息，无论是否私有（破坏类的封装性）
			 * 3.至此，我们已经通过.class字节码文件，获取到了.java.源文件的类的信息。这就是反射的分析类作用。
			 * 4.~明天再试试，如何利用反射来创建实例，并操作类的方法，修改类的属性等……
			 */
			Class aim = Class.forName("java.lang.String");//e.g. java.lang.String
			System.out.printf("%s extends %s %n{%n", aim.toString(), aim.getSuperclass());
			printAllDeclaredConstructors(aim);
			System.out.println();
			printAllDeclaredMethods(aim);
			System.out.println();
			printAllDeclaredFileds(aim);
			System.out.println("}");
			
			/**4.11
			 * 4.通过反射机制来获取类信息，并通过Constructor来getDeclaredConstructor创建类的实例对象。
			 * 5.通过Method对实例对象调用类的方法。
			 * 6.通过Field对实例对象的类的属性进行访问或修改。
			 * 7.通过配置文件Simple.cfg来加载类
			 * 8.明白反射机制其实是用于-->>动态加载需要的类（加载我们在配置文件所输入的类，而不是源代码中固定的类），而不需要重新编译.java源文件.
			 * 
			 */
			try {
				/**
				 * 读取Simple.cfg配置文件中的配置，利用反射机制来实现动态地加载所需类，让它自动地执行下面的操作.
				 */
				File simpleCfg = new File("Simple.cfg");//相对路径。
				HashMap<String, String> cfg = readCfg(simpleCfg);
				aim = Class.forName(cfg.get("Class"));//参数配置
				String methodName = cfg.get("Method");
				String fielddName = cfg.get("Field");
				Class paramType;
				if(cfg.get("ParamType").equals("int")){
					paramType = int.class;//如果是基础数据类型，
				}else{
					paramType = Class.forName(cfg.get("ParamType"));
				}
				
				Object value;
				if(cfg.get("FieldParam").equals("int")){
				        value = Integer.parseInt(cfg.get("Value"));//如果是基础数据类型，
				}else{
						value = cfg.get("Value");
				}
				
				

				Constructor cons = aim.getDeclaredConstructor(java.lang.StringBuilder.class);
				// cons.setAccessible(true);//该方法用于private等没有权限访问的情况。破坏了类的封装性。
				StringBuilder info = new StringBuilder();
				info.append("I L JAVA ?");
				Object ob = cons.newInstance(info);// ob引用了实例对象

				Method method = aim.getDeclaredMethod(methodName, paramType);//参数配置
//				Method method = aim.getDeclaredMethod("charAt", int.class);// 调用String的chatAt(int)
				String name = method.getName();
				String str1 = method.invoke(ob, 0).toString();
				String str2 = method.invoke(ob, 4).toString();
				System.out.printf("我们用%s方法得到的是第1个字符：%s  以及第五个字符：%s%n", name, str1, str2);// 调用ob对象的charAt（int）方法

				Field f = aim.getDeclaredField(fielddName);//参数配置
//				Field f = aim.getDeclaredField("hash");// 获取String的声明字段hash
				f.setAccessible(true);// hash字段属于private字段，我们需要权限。
				name = f.getName();// 字段名
				String orig = f.get(ob).toString();// 字段值；虽然我们知道hash是int类型，但是用这个get()会更通用。
				
				f.set(ob, value);// 这里调用了setHash（）如果有的话~
				String now = f.get(ob).toString();// 修改后的值
				String modifier =f.getModifiers()==2?"private":"NotPrivate";//private对应于2
				System.out.printf("我们访问了属性%s,需要%s权限,该属性的值是：%s,我们修改成：%s", name, modifier, orig, now);

			} catch (NoSuchMethodException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (SecurityException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InstantiationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IllegalArgumentException e) {
				
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (NoSuchFieldException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (Exception e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			
			
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

}
